1. 根视图为一个navigationViewController,上面是一个TabBarController

2. 每一个bar item所在页里面都嵌套一个table获取view的控制器

3. 静态Cells类型的table的style 要设置成group

4. 让navigationBar底部线条隐藏的方法
//自定义背景图和自定义shadow图
[self.navigationController.navigationBar setBackgroundImage:[[UIImage alloc] init] forBarMetrics:UIBarMetricsDefault];
[self.navigationController.navigationBar setShadowImage:[[UIImage alloc] init]];//用于去除导航栏的底线，也就是周围的边线

5. 自定义navBar返回按钮用的是UIBarButtonItem对象

6. 一个tab控制器嵌套一个nav控制器,nav控制器push一个视图的时候如果设置为hideBottomBarOnPush的话,效果就是微信那样.而nav控制器嵌套tab控制器,然后push一个视图的话,不需要设置hideBottomBarOnPush效果也是微信那样.不过后者的话一会所有页面的navigationBar都是同一个这样就很不方便,毕竟一般情况下,不同页面有着不同的navigationBar.

***************重大更新***********
7. 现在整体结构修改成了tab控制器嵌套nav控制器

8. 按照第7步修改之后,要设置tab里面每一个页面的标题,必须使用self.navigationItem.title = @"活石";而不是原来的self.tabBarController.title = @"活石";

9. CollectView 新增或者删除Cell的时候,系统会自动在指定位置添加cell,其他原有的cell不会重新加载

10. CollectViewCell 里面的label用特殊字体,导致在iOS8.4中Cell的加载速度异常慢,切换默认字体则正常.

11. 每一个collectionView 都必须独享一个UICollectionViewLayout对象,否则做插入操作会报EXC_BAD_ACCESS错误😩

12. collectionView可以设置allowsMultipleSelection,NO时,点击同一个cell只会触发didSelectItemAtIndexPath方法,点击其他cell则先触发上一次点击的cell的didDeSelectItemAtIndexPath,再触发当前点击cell的didSelectItemAtIndexPath.YES时,则点击不同的cell都触发didSelectItemAtIndexPath,点击同一个cell则轮流触发didSelectItemAtIndexPath和didDeSelectItemAtIndexPath

13. 一定要留意如果移除了一个cell,则在这个cell之后的所有cell对应的indxPath都会变化.所以如果在移除cell之前有记录了某个cell的位置,移除cell之后,这个cell的indexPath可能会发生变化,要特别注意.....

14. collectionViewCell.xib文件中对cell加入的任何元素,比如按钮,最终都无法响应任何事件.因为这些元素会被cell的contentView覆盖了.所以要把这些元素加到cell的contentView里面才行.有一个巧妙的方法,就是先在xib文件里面编辑好元素,然后等到元素要显示之前,用addSubView把他们重新添加到contentView里面就好

15. collectionViewCell嵌套collectionView,被嵌套的collectionView里面的cell里的按钮点击之后,按钮和collectionView的selected事件不会同时响应

16. 设置UIButton标题的时候,不能误用titleLabel.text属性去设置,因为不管你怎么设置,这个label的frame是0,0,0,0..所以应该使用官方提供的-setTitle:forState:方法......

17. 圣经页面的最终实现原理
    整体上是一个collectionView,数据源是这个界面上的UIViewController,然后UICollectionViewDelegate, UICollectionViewDelegateFlowLayout是collectionView(A)自身实现的(因为总共有2个collectionView),然后那个有详细章节的cell(detailCell),由UIViewController控制,detailCell里面又嵌套了一个collectionView(B),B的数据源detailCell,detailCell同时实现了UICollectionViewDelegate, UICollectionViewDataSource, UICollectionViewDelegateFlowLayout这三个协议,然后detailCell里面的章节cell(就是那些圆数字)里面是按钮,但是当你点击按钮的时候,并不会触发B的didSelectItemAtIndexPath,所以需要从章节cell里面再声明一个自定义代理然后由detailCell实现,按钮被点击时,通知detailCell,这样才能完整实现这个效果...........
    还有一个地方就是UIViewController要分配两个一样的数据(这里主要是每一本书的章节数量,我写死了50个)给A和detailCell,这样在A里面才能计算出detailCell的高度,然后detailCell里面才能计算出B的Cell的数量....