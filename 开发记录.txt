1. 根视图为一个navigationViewController,上面是一个TabBarController

2. 每一个bar item所在页里面都嵌套一个table获取view的控制器

3. 静态Cells类型的table的style 要设置成group

4. 让navigationBar底部线条隐藏的方法
//自定义背景图和自定义shadow图
[self.navigationController.navigationBar setBackgroundImage:[[UIImage alloc] init] forBarMetrics:UIBarMetricsDefault];
[self.navigationController.navigationBar setShadowImage:[[UIImage alloc] init]];//用于去除导航栏的底线，也就是周围的边线

5. 自定义navBar返回按钮用的是UIBarButtonItem对象

6. 一个tab控制器嵌套一个nav控制器,nav控制器push一个视图的时候如果设置为hideBottomBarOnPush的话,效果就是微信那样.而nav控制器嵌套tab控制器,然后push一个视图的话,不需要设置hideBottomBarOnPush效果也是微信那样.不过后者的话一会所有页面的navigationBar都是同一个这样就很不方便,毕竟一般情况下,不同页面有着不同的navigationBar.

***************重大更新***********
7. 现在整体结构修改成了tab控制器嵌套nav控制器

8. 按照第7步修改之后,要设置tab里面每一个页面的标题,必须使用self.navigationItem.title = @"活石";而不是原来的self.tabBarController.title = @"活石";

9. CollectView 新增或者删除Cell的时候,系统会自动在指定位置添加cell,其他原有的cell不会重新加载

10. CollectViewCell 里面的label用特殊字体,导致在iOS8.4中Cell的加载速度异常慢,切换默认字体则正常.

11. 每一个collectionView 都必须独享一个UICollectionViewLayout对象,否则做插入操作会报EXC_BAD_ACCESS错误😩

12. collectionView可以设置allowsMultipleSelection,NO时,点击同一个cell只会触发didSelectItemAtIndexPath方法,点击其他cell则先触发上一次点击的cell的didDeSelectItemAtIndexPath,再触发当前点击cell的didSelectItemAtIndexPath.YES时,则点击不同的cell都触发didSelectItemAtIndexPath,点击同一个cell则轮流触发didSelectItemAtIndexPath和didDeSelectItemAtIndexPath

13. 一定要留意如果移除了一个cell,则在这个cell之后的所有cell对应的indxPath都会变化.所以如果在移除cell之前有记录了某个cell的位置,移除cell之后,这个cell的indexPath可能会发生变化,要特别注意.....

14. collectionViewCell.xib文件中对cell加入的任何元素,比如按钮,最终都无法响应任何事件.因为这些元素会被cell的contentView覆盖了.所以要把这些元素加到cell的contentView里面才行.有一个巧妙的方法,就是先在xib文件里面编辑好元素,然后等到元素要显示之前,用addSubView把他们重新添加到contentView里面就好

15. collectionViewCell嵌套collectionView,被嵌套的collectionView里面的cell里的按钮点击之后,按钮和collectionView的selected事件不会同时响应

16. 设置UIButton标题的时候,不能误用titleLabel.text属性去设置,因为不管你怎么设置,这个label的frame是0,0,0,0..所以应该使用官方提供的-setTitle:forState:方法......

17. 圣经页面的最终实现原理
    整体上是一个collectionView,数据源是这个界面上的UIViewController,然后UICollectionViewDelegate, UICollectionViewDelegateFlowLayout是collectionView(A)自身实现的(因为总共有2个collectionView),然后那个有详细章节的cell(detailCell),由UIViewController控制,detailCell里面又嵌套了一个collectionView(B),B的数据源detailCell,detailCell同时实现了UICollectionViewDelegate, UICollectionViewDataSource, UICollectionViewDelegateFlowLayout这三个协议,然后detailCell里面的章节cell(就是那些圆数字)里面是按钮,但是当你点击按钮的时候,并不会触发B的didSelectItemAtIndexPath,所以需要从章节cell里面再声明一个自定义代理然后由detailCell实现,按钮被点击时,通知detailCell,这样才能完整实现这个效果...........
    还有一个地方就是UIViewController要分配两个一样的数据(这里主要是每一本书的章节数量,我写死了50个)给A和detailCell,这样在A里面才能计算出detailCell的高度,然后detailCell里面才能计算出B的Cell的数量....

18 字典转json,比较麻烦.NSMutableDictionary *jsonDic = [[NSMutableDictionary alloc] init];NSData *jsonData = [NSJSONSerialization dataWithJSONObject:jsonDic options:0 error:nil];NSLog(@"%@",[[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding]);

19 iOS8中发现UITableViewCellSelectionStyle中除了默认效果和UITableViewCellSelectionStyleNone,其他效果设置后均无效.

20.tabBarController 下的item的selected状态下的图标必须用代码设置:
discoveryItem.selectedImage = [[UIImage imageNamed:@"DiscoverySelc"] imageWithRenderingMode: UIImageRenderingModeAlwaysOriginal];

21. tableview static 混合dynamic的方法,就是先设计好static cell,加载tableview时候会调用数据源,数据源中的cellForRowAtIndexPath方法是根据static cell来调用的,这时候可以针对特定的cell一定义,如果不想改变原来设计的static cell,则调用super方法并且作为返回值就可以

22.AFNetworking 3.0使用记录
AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
NSDictionary *requestContents = @{
    @"receipt-data": [receipt base64EncodedStringWithOptions:0]
};
- (nullable NSURLSessionDataTask *)GET:(NSString *)URLString
                            parameters:(nullable id)parameters
                              progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgress
                               success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success
                               failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;
	1).post带参数
	直接将参数放在parameters上
	2).提示不接收服务器的返回类型,例如不接受text/plain
	// manager.responseSerializer默认就是期望JSON类型的response:AFJSONResponseSerializer
	manager.responseSerializer.acceptableContentTypes = [NSSet setWithObject:@"text/plain"];
	3).设置Header
	manager.requestSerializer setAuthorizationHeaderFieldWithUsername:(nonnull NSString *) password:(nonnull NSString *)



23.在scrollview中设置的元素的高,顶,左右,居中约束后还提示scrollView约束有歧义,可以看到 Storyboard 错误提示：ScrollView has ambiguous scrollable content height。这是怎么一回事呢？
我们知道，UIScrollView 有一个 contentSize 属性，其定义了 ScrollView 可滚动内容的大小。在以前用纯代码写的时候，我们会直接对这个属性赋值，定义其大小。但在 Autolayout 下，UIScrollView 的 contentSize 是由其内容的约束来定义的。因此，我们在 ScrollView 里面设置的约束，不仅起到布局内容的作用，同时也起到了定义 ScrollView 可滚动范围的作用。
针对上面的例子具体来说，ScrollView 知道它里面有个 View，其高度是 200，距离顶上为 55，但仅通过这两个约束没办法知道它的 contentSize 的高度是多少，我们缺少一个定义 View 到 ScrollView 底部距离的约束。
参考:http://www.cocoachina.com/ios/20141118/10242.html

24. 针对不同机型,如果需要设置scorllView和contentSize差不多大,需要在代码用对约束进行调整.比如确定元素底部离scorllView底部的实际距离,然后再赋值给约束.







